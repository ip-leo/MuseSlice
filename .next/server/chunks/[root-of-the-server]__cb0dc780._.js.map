{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 154, "column": 0}, "map": {"version":3,"sources":["file:///Users/leoip/Library/Mobile%20Documents/com~apple~CloudDocs/Downloads/Intern/Personal_Projects/MuseSlice/src/lib/auth.ts"],"sourcesContent":["import { NextAuthOptions } from \"next-auth\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\nimport { PrismaAdapter } from \"@auth/prisma-adapter\";\nimport { PrismaClient } from \"@prisma/client\";\nimport bcrypt from \"bcryptjs\";\n\n// Create a single Prisma instance to prevent multiple connections\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nconst prisma = globalForPrisma.prisma ?? new PrismaClient();\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n\nexport const authOptions: NextAuthOptions = {\n  adapter: PrismaAdapter(prisma),\n  providers: [\n    CredentialsProvider({\n      name: \"credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"email\" },\n        password: { label: \"Password\", type: \"password\" }\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) {\n          return null;\n        }\n\n        const user = await prisma.user.findUnique({\n          where: {\n            email: credentials.email\n          }\n        });\n\n        if (!user || !user.password) {\n          return null;\n        }\n\n        const isPasswordValid = await bcrypt.compare(\n          credentials.password,\n          user.password\n        );\n\n        if (!isPasswordValid) {\n          return null;\n        }\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          image: user.image,\n        };\n      }\n    })\n  ],\n  session: {\n    strategy: \"jwt\"\n  },\n  pages: {\n    signIn: \"/auth/signin\",\n    signUp: \"/auth/signup\",\n  },\n  callbacks: {\n    async jwt({ token, user }) {\n      // Always ensure id is present\n      if (user) {\n        token.id = user.id;\n      }\n      // Ensure createdAt is attached; fetch if missing\n      // @ts-ignore\n      if (!token.createdAt && token.id) {\n        try {\n          const dbUser = await prisma.user.findUnique({ where: { id: token.id as string } });\n          if (dbUser?.createdAt) {\n            // @ts-ignore\n            token.createdAt = dbUser.createdAt.toISOString();\n          }\n        } catch {}\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (token) {\n        session.user.id = token.id as string;\n        // @ts-ignore\n        if (token.createdAt) {\n          // @ts-ignore\n          (session.user as any).createdAt = token.createdAt as string;\n        }\n      }\n      return session;\n    }\n  }\n};\n"],"names":[],"mappings":";;;AACA;AACA;AACA;AACA;;;;;AAEA,kEAAkE;AAClE,MAAM,kBAAkB;AAIxB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6HAAA,CAAA,eAAY;AAEzD,wCAA2C,gBAAgB,MAAM,GAAG;AAE7D,MAAM,cAA+B;IAC1C,SAAS,CAAA,GAAA,sJAAA,CAAA,gBAAa,AAAD,EAAE;IACvB,WAAW;QACT,CAAA,GAAA,0JAAA,CAAA,UAAmB,AAAD,EAAE;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;oBACjD,OAAO;gBACT;gBAEA,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC;oBACxC,OAAO;wBACL,OAAO,YAAY,KAAK;oBAC1B;gBACF;gBAEA,IAAI,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE;oBAC3B,OAAO;gBACT;gBAEA,MAAM,kBAAkB,MAAM,mIAAA,CAAA,UAAM,CAAC,OAAO,CAC1C,YAAY,QAAQ,EACpB,KAAK,QAAQ;gBAGf,IAAI,CAAC,iBAAiB;oBACpB,OAAO;gBACT;gBAEA,OAAO;oBACL,IAAI,KAAK,EAAE;oBACX,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;oBACf,OAAO,KAAK,KAAK;gBACnB;YACF;QACF;KACD;IACD,SAAS;QACP,UAAU;IACZ;IACA,OAAO;QACL,QAAQ;QACR,QAAQ;IACV;IACA,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,8BAA8B;YAC9B,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;YACpB;YACA,iDAAiD;YACjD,aAAa;YACb,IAAI,CAAC,MAAM,SAAS,IAAI,MAAM,EAAE,EAAE;gBAChC,IAAI;oBACF,MAAM,SAAS,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC;wBAAE,OAAO;4BAAE,IAAI,MAAM,EAAE;wBAAW;oBAAE;oBAChF,IAAI,QAAQ,WAAW;wBACrB,aAAa;wBACb,MAAM,SAAS,GAAG,OAAO,SAAS,CAAC,WAAW;oBAChD;gBACF,EAAE,OAAM,CAAC;YACX;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,OAAO;gBACT,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;gBAC1B,aAAa;gBACb,IAAI,MAAM,SAAS,EAAE;oBACnB,aAAa;oBACZ,QAAQ,IAAI,CAAS,SAAS,GAAG,MAAM,SAAS;gBACnD;YACF;YACA,OAAO;QACT;IACF;AACF","debugId":null}},
    {"offset": {"line": 256, "column": 0}, "map": {"version":3,"sources":["file:///Users/leoip/Library/Mobile%20Documents/com~apple~CloudDocs/Downloads/Intern/Personal_Projects/MuseSlice/src/app/api/user/audio-files/clear/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/lib/auth';\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\nexport async function DELETE(_request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions);\n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const user = await prisma.user.findUnique({ where: { email: session.user.email } });\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 });\n    }\n\n    // Attempt best-effort cleanup of backend files for this user's sessions\n    const serviceUrl = process.env.NEXT_PUBLIC_AUDIO_SERVICE_URL || 'http://localhost:5002';\n    try {\n      const files = await prisma.audioFile.findMany({\n        where: { userId: user.id },\n        select: { sessionId: true, outputSessionId: true },\n      });\n      const uniqueIds = new Set<string>();\n      for (const f of files) {\n        if (f.sessionId) uniqueIds.add(f.sessionId);\n        if (f.outputSessionId) uniqueIds.add(f.outputSessionId);\n      }\n      await Promise.all(\n        Array.from(uniqueIds).map(async (id) => {\n          try {\n            await fetch(`${serviceUrl}/cleanup/${id}`, { method: 'DELETE', cache: 'no-store' });\n          } catch {}\n        })\n      );\n    } catch {}\n\n    const result = await prisma.audioFile.deleteMany({ where: { userId: user.id } });\n    return NextResponse.json({ success: true, deleted: result.count });\n\n  } catch (error) {\n    console.error('Error clearing audio history:', error);\n    return NextResponse.json({ error: 'Failed to clear history' }, { status: 500 });\n  }\n}\n\nexport const dynamic = 'force-dynamic';\n\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,SAAS,IAAI,6HAAA,CAAA,eAAY;AAExB,eAAe,OAAO,QAAqB;IAChD,IAAI;QACF,MAAM,UAAU,MAAM,CAAA,GAAA,uIAAA,CAAA,mBAAgB,AAAD,EAAE,oHAAA,CAAA,cAAW;QAClD,IAAI,CAAC,SAAS,MAAM,OAAO;YACzB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC;YAAE,OAAO;gBAAE,OAAO,QAAQ,IAAI,CAAC,KAAK;YAAC;QAAE;QACjF,IAAI,CAAC,MAAM;YACT,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAiB,GAAG;gBAAE,QAAQ;YAAI;QACtE;QAEA,wEAAwE;QACxE,MAAM,aAAa,6DAA6C;QAChE,IAAI;YACF,MAAM,QAAQ,MAAM,OAAO,SAAS,CAAC,QAAQ,CAAC;gBAC5C,OAAO;oBAAE,QAAQ,KAAK,EAAE;gBAAC;gBACzB,QAAQ;oBAAE,WAAW;oBAAM,iBAAiB;gBAAK;YACnD;YACA,MAAM,YAAY,IAAI;YACtB,KAAK,MAAM,KAAK,MAAO;gBACrB,IAAI,EAAE,SAAS,EAAE,UAAU,GAAG,CAAC,EAAE,SAAS;gBAC1C,IAAI,EAAE,eAAe,EAAE,UAAU,GAAG,CAAC,EAAE,eAAe;YACxD;YACA,MAAM,QAAQ,GAAG,CACf,MAAM,IAAI,CAAC,WAAW,GAAG,CAAC,OAAO;gBAC/B,IAAI;oBACF,MAAM,MAAM,GAAG,WAAW,SAAS,EAAE,IAAI,EAAE;wBAAE,QAAQ;wBAAU,OAAO;oBAAW;gBACnF,EAAE,OAAM,CAAC;YACX;QAEJ,EAAE,OAAM,CAAC;QAET,MAAM,SAAS,MAAM,OAAO,SAAS,CAAC,UAAU,CAAC;YAAE,OAAO;gBAAE,QAAQ,KAAK,EAAE;YAAC;QAAE;QAC9E,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,SAAS;YAAM,SAAS,OAAO,KAAK;QAAC;IAElE,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA0B,GAAG;YAAE,QAAQ;QAAI;IAC/E;AACF;AAEO,MAAM,UAAU","debugId":null}}]
}