{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 154, "column": 0}, "map": {"version":3,"sources":["file:///Users/leoip/Library/Mobile%20Documents/com~apple~CloudDocs/Downloads/Intern/Personal_Projects/MuseSlice/src/lib/auth.ts"],"sourcesContent":["import { NextAuthOptions } from \"next-auth\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\nimport { PrismaAdapter } from \"@auth/prisma-adapter\";\nimport { PrismaClient } from \"@prisma/client\";\nimport bcrypt from \"bcryptjs\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nconst prisma = globalForPrisma.prisma ?? new PrismaClient();\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n\nexport const authOptions: NextAuthOptions = {\n  adapter: PrismaAdapter(prisma),\n  providers: [\n    CredentialsProvider({\n      name: \"credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"email\" },\n        password: { label: \"Password\", type: \"password\" }\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) {\n          return null;\n        }\n\n        const user = await prisma.user.findUnique({\n          where: {\n            email: credentials.email\n          }\n        });\n\n        if (!user || !user.password) {\n          return null;\n        }\n\n        const isPasswordValid = await bcrypt.compare(\n          credentials.password,\n          user.password\n        );\n\n        if (!isPasswordValid) {\n          return null;\n        }\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          image: user.image,\n        };\n      }\n    })\n  ],\n  session: {\n    strategy: \"jwt\"\n  },\n  pages: {\n    signIn: \"/auth/signin\",\n    signUp: \"/auth/signup\",\n  },\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id;\n      }\n      if (!token.createdAt && token.id) {\n        try {\n          const dbUser = await prisma.user.findUnique({ where: { id: token.id as string } });\n          if (dbUser?.createdAt) {\n            token.createdAt = dbUser.createdAt.toISOString();\n          }\n        } catch {}\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (token) {\n        session.user.id = token.id as string;\n        if (token.createdAt) {\n          (session.user as any).createdAt = token.createdAt as string;\n        }\n      }\n      return session;\n    }\n  }\n};\n"],"names":[],"mappings":";;;AACA;AACA;AACA;AACA;;;;;AAEA,MAAM,kBAAkB;AAIxB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6HAAA,CAAA,eAAY;AAEzD,wCAA2C,gBAAgB,MAAM,GAAG;AAE7D,MAAM,cAA+B;IAC1C,SAAS,CAAA,GAAA,sJAAA,CAAA,gBAAa,AAAD,EAAE;IACvB,WAAW;QACT,CAAA,GAAA,0JAAA,CAAA,UAAmB,AAAD,EAAE;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;oBACjD,OAAO;gBACT;gBAEA,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC;oBACxC,OAAO;wBACL,OAAO,YAAY,KAAK;oBAC1B;gBACF;gBAEA,IAAI,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE;oBAC3B,OAAO;gBACT;gBAEA,MAAM,kBAAkB,MAAM,mIAAA,CAAA,UAAM,CAAC,OAAO,CAC1C,YAAY,QAAQ,EACpB,KAAK,QAAQ;gBAGf,IAAI,CAAC,iBAAiB;oBACpB,OAAO;gBACT;gBAEA,OAAO;oBACL,IAAI,KAAK,EAAE;oBACX,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;oBACf,OAAO,KAAK,KAAK;gBACnB;YACF;QACF;KACD;IACD,SAAS;QACP,UAAU;IACZ;IACA,OAAO;QACL,QAAQ;QACR,QAAQ;IACV;IACA,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;YACpB;YACA,IAAI,CAAC,MAAM,SAAS,IAAI,MAAM,EAAE,EAAE;gBAChC,IAAI;oBACF,MAAM,SAAS,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC;wBAAE,OAAO;4BAAE,IAAI,MAAM,EAAE;wBAAW;oBAAE;oBAChF,IAAI,QAAQ,WAAW;wBACrB,MAAM,SAAS,GAAG,OAAO,SAAS,CAAC,WAAW;oBAChD;gBACF,EAAE,OAAM,CAAC;YACX;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,OAAO;gBACT,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;gBAC1B,IAAI,MAAM,SAAS,EAAE;oBAClB,QAAQ,IAAI,CAAS,SAAS,GAAG,MAAM,SAAS;gBACnD;YACF;YACA,OAAO;QACT;IACF;AACF","debugId":null}},
    {"offset": {"line": 249, "column": 0}, "map": {"version":3,"sources":["file:///Users/leoip/Library/Mobile%20Documents/com~apple~CloudDocs/Downloads/Intern/Personal_Projects/MuseSlice/src/app/api/user/audio-files/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getServerSession } from 'next-auth';\nimport { authOptions } from '@/lib/auth';\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions);\n    \n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const body = await request.json();\n    const {\n      originalFileName,\n      originalFileSize,\n      originalFileType,\n      sessionId,\n      detectedInstruments,\n      selectedInstruments,\n      separatedTracks,\n      audioMetadata,\n      processingStatus = 'completed',\n      fileExpiresAt, \n      filesAvailable \n    } = body;\n\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email }\n    });\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 });\n    }\n\n    let audioFile;\n    const existing = sessionId ? await prisma.audioFile.findFirst({\n      where: { userId: user.id, sessionId },\n    }) : null;\n\n    const dataToWrite: any = {\n      userId: user.id,\n      originalFileName,\n      originalFileSize,\n      originalFileType,\n      sessionId,\n      processingStatus,\n      processingCompletedAt: processingStatus === 'completed' ? new Date() : undefined,\n      filesAvailable: filesAvailable ?? true,\n      fileExpiresAt: fileExpiresAt ? new Date(fileExpiresAt) : undefined,\n    };\n\n    if (detectedInstruments !== undefined) dataToWrite.detectedInstruments = JSON.stringify(detectedInstruments);\n    if (selectedInstruments !== undefined) dataToWrite.selectedInstruments = JSON.stringify(selectedInstruments);\n    if (separatedTracks !== undefined) dataToWrite.separatedTracks = JSON.stringify(separatedTracks);\n    if (audioMetadata !== undefined) dataToWrite.audioMetadata = JSON.stringify(audioMetadata);\n    if (body.outputSessionId) dataToWrite.outputSessionId = body.outputSessionId;\n\n    if (existing) {\n      audioFile = await prisma.audioFile.update({\n        where: { id: existing.id },\n        data: dataToWrite,\n      });\n    } else {\n      audioFile = await prisma.audioFile.create({\n        data: dataToWrite,\n      });\n    }\n\n    return NextResponse.json({ \n      success: true, \n      audioFileId: audioFile.id \n    });\n\n  } catch (error) {\n    console.error('Error saving audio file:', error);\n    return NextResponse.json(\n      { error: 'Failed to save audio file' }, \n      { status: 500 }\n    );\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions);\n    \n    if (!session?.user?.email) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email }\n    });\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 });\n    }\n\n    const audioFiles = await prisma.audioFile.findMany({\n      where: { userId: user.id },\n      orderBy: { uploadedAt: 'desc' }\n    });\n\n    const processedAudioFiles = audioFiles.map(file => ({\n      ...file,\n      detectedInstruments: file.detectedInstruments ? JSON.parse(file.detectedInstruments) : null,\n      selectedInstruments: file.selectedInstruments ? JSON.parse(file.selectedInstruments) : null,\n      separatedTracks: file.separatedTracks ? JSON.parse(file.separatedTracks) : null,\n      audioMetadata: file.audioMetadata ? JSON.parse(file.audioMetadata) : null\n    }));\n\n    return NextResponse.json({ audioFiles: processedAudioFiles });\n\n  } catch (error) {\n    console.error('Error fetching audio files:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch audio files' }, \n      { status: 500 }\n    );\n  }\n} \n"],"names":[],"mappings":"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","debugId":null}}]
}